import { shallowEqual } from "fast-equals";
function markApplies(doc, from, to, type) {
    let applies = false;
    doc.nodesBetween(from, to, (node, pos, parent) => {
        if (applies) {
            return false;
        }
        applies = node.isInline && parent.type.allowsMarkType(type);
    });
    return applies;
}
// return true iff all nodes in range have the mark with the same attrs
function rangeHasMark(doc, from, to, type, attrs) {
    let hasMark = null;
    doc.nodesBetween(from, to, node => {
        for (let i = 0; i < node.marks.length; i++) {
            const markMatch = node.marks[i].type === type && (!attrs || shallowEqual(node.marks[i].attrs, attrs));
            hasMark = (markMatch && (hasMark === null || hasMark === true));
        }
        return hasMark;
    });
    return !!hasMark;
}
export function toggleInlineMark(markType, attrs) {
    return function (state, dispatch) {
        const { empty, from, to, $from } = state.selection;
        if (!markApplies(state.doc, from, to, markType)) {
            console.log("not applies");
            return false;
        }
        if (dispatch) {
            if (empty) {
                const markInSet = markType.isInSet(state.storedMarks || $from.marks());
                if (markInSet && (!attrs || shallowEqual(markInSet.attrs, attrs))) {
                    dispatch(state.tr.removeStoredMark(markType));
                }
                else {
                    dispatch(state.tr.addStoredMark(markType.create(attrs)));
                }
            }
            else {
                if (rangeHasMark(state.doc, from, to, markType, attrs)) {
                    dispatch(state.tr.removeMark(from, to, markType).scrollIntoView());
                }
                else {
                    dispatch(state.tr.addMark(from, to, markType.create(attrs)).scrollIntoView());
                }
            }
        }
        return true;
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vZ2xlLWlubGluZS1tYXJrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2h0bWwtZWRpdG9yL3Byb3NlbWlycm9yL2NvbW1hbmRzL3Rvb2dsZS1pbmxpbmUtbWFyay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sYUFBYSxDQUFDO0FBSXpDLFNBQVMsV0FBVyxDQUFDLEdBQVMsRUFBRSxJQUFZLEVBQUUsRUFBVSxFQUFFLElBQWM7SUFFcEUsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDO0lBRXBCLEdBQUcsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEVBQUU7UUFFN0MsSUFBSSxPQUFPLEVBQUU7WUFDVCxPQUFPLEtBQUssQ0FBQztTQUNoQjtRQUVELE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2hFLENBQUMsQ0FBQyxDQUFDO0lBRUgsT0FBTyxPQUFPLENBQUM7QUFDbkIsQ0FBQztBQUVELHVFQUF1RTtBQUN2RSxTQUFTLFlBQVksQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsS0FBSztJQUU1QyxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUM7SUFFbkIsR0FBRyxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFFLElBQUksQ0FBQyxFQUFFO1FBRTlCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN4QyxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDLEtBQUssSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUN0RyxPQUFPLEdBQUcsQ0FBQyxTQUFTLElBQUksQ0FBQyxPQUFPLEtBQUssSUFBSSxJQUFJLE9BQU8sS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ25FO1FBRUQsT0FBTyxPQUFPLENBQUM7SUFDbkIsQ0FBQyxDQUFDLENBQUM7SUFFSCxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUM7QUFDckIsQ0FBQztBQUVELE1BQU0sVUFBVSxnQkFBZ0IsQ0FBQyxRQUFrQixFQUFFLEtBQTRCO0lBRTdFLE9BQU8sVUFBUyxLQUFLLEVBQUUsUUFBUTtRQUUzQixNQUFNLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQztRQUVuRCxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsRUFBRTtZQUM3QyxPQUFPLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQzNCLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBRUQsSUFBSSxRQUFRLEVBQUU7WUFFVixJQUFJLEtBQUssRUFBRTtnQkFFUCxNQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxXQUFXLElBQUksS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7Z0JBRXZFLElBQUksU0FBUyxJQUFJLENBQUMsQ0FBQyxLQUFLLElBQUksWUFBWSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRTtvQkFDL0QsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztpQkFDakQ7cUJBQU07b0JBQ0gsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUM1RDthQUVKO2lCQUFNO2dCQUVILElBQUksWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxRQUFRLEVBQUUsS0FBSyxDQUFDLEVBQUU7b0JBQ3BELFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUM7aUJBQ3RFO3FCQUFNO29CQUNILFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFFLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDO2lCQUNqRjthQUNKO1NBQ0o7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDLENBQUM7QUFDTixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtzaGFsbG93RXF1YWx9IGZyb20gXCJmYXN0LWVxdWFsc1wiO1xuaW1wb3J0IHtNYXJrVHlwZSwgTm9kZX0gZnJvbSBcInByb3NlbWlycm9yLW1vZGVsXCI7XG5pbXBvcnQge0NvbW1hbmR9IGZyb20gXCIuLi9jb21tYW5kXCI7XG5cbmZ1bmN0aW9uIG1hcmtBcHBsaWVzKGRvYzogTm9kZSwgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyLCB0eXBlOiBNYXJrVHlwZSkge1xuXG4gICAgbGV0IGFwcGxpZXMgPSBmYWxzZTtcblxuICAgIGRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MsIHBhcmVudCkgPT4ge1xuXG4gICAgICAgIGlmIChhcHBsaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBhcHBsaWVzID0gbm9kZS5pc0lubGluZSAmJiBwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZSh0eXBlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBhcHBsaWVzO1xufVxuXG4vLyByZXR1cm4gdHJ1ZSBpZmYgYWxsIG5vZGVzIGluIHJhbmdlIGhhdmUgdGhlIG1hcmsgd2l0aCB0aGUgc2FtZSBhdHRyc1xuZnVuY3Rpb24gcmFuZ2VIYXNNYXJrKGRvYywgZnJvbSwgdG8sIHR5cGUsIGF0dHJzKSB7XG5cbiAgICBsZXQgaGFzTWFyayA9IG51bGw7XG5cbiAgICBkb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBub2RlID0+IHtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtNYXRjaCA9IG5vZGUubWFya3NbaV0udHlwZSA9PT0gdHlwZSAmJiAoIWF0dHJzIHx8IHNoYWxsb3dFcXVhbChub2RlLm1hcmtzW2ldLmF0dHJzLCBhdHRycykpO1xuICAgICAgICAgICAgaGFzTWFyayA9IChtYXJrTWF0Y2ggJiYgKGhhc01hcmsgPT09IG51bGwgfHwgaGFzTWFyayA9PT0gdHJ1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhhc01hcms7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gISFoYXNNYXJrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlSW5saW5lTWFyayhtYXJrVHlwZTogTWFya1R5cGUsIGF0dHJzPzoge1trZXk6IHN0cmluZ106IGFueX0pOiBDb21tYW5kIHtcblxuICAgIHJldHVybiBmdW5jdGlvbihzdGF0ZSwgZGlzcGF0Y2gpIHtcblxuICAgICAgICBjb25zdCB7IGVtcHR5LCBmcm9tLCB0bywgJGZyb20gfSA9IHN0YXRlLnNlbGVjdGlvbjtcblxuICAgICAgICBpZiAoIW1hcmtBcHBsaWVzKHN0YXRlLmRvYywgZnJvbSwgdG8sIG1hcmtUeXBlKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJub3QgYXBwbGllc1wiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuXG4gICAgICAgICAgICBpZiAoZW1wdHkpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtJblNldCA9IG1hcmtUeXBlLmlzSW5TZXQoc3RhdGUuc3RvcmVkTWFya3MgfHwgJGZyb20ubWFya3MoKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWFya0luU2V0ICYmICghYXR0cnMgfHwgc2hhbGxvd0VxdWFsKG1hcmtJblNldC5hdHRycywgYXR0cnMpKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuYWRkU3RvcmVkTWFyayhtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlSGFzTWFyayhzdGF0ZS5kb2MsIGZyb20sIHRvLCBtYXJrVHlwZSwgYXR0cnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnJlbW92ZU1hcmsoZnJvbSwgdG8sIG1hcmtUeXBlKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5hZGRNYXJrKGZyb20sIHRvLCBtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuXG4iXX0=