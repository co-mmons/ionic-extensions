/**
 * Toggles block mark based on the return type of `getAttrs`.
 * This is similar to ProseMirror"s `getAttrs` from `AttributeSpec`
 * return `false` to remove the mark.
 * return `undefined for no-op.
 * return an `object` to update the mark.
 */
export const toggleBlockMark = (markType, getAttrs, allowedBlocks) => (state, dispatch) => {
    let markApplied = false;
    const tr = state.tr;
    const toggleBlockMarkOnRange = (from, to, tr) => {
        state.doc.nodesBetween(from, to, (node, pos, parent) => {
            if (!node.type.isBlock) {
                return false;
            }
            if ((!allowedBlocks || (Array.isArray(allowedBlocks) ? allowedBlocks.indexOf(node.type) > -1 : allowedBlocks(state.schema, node, parent))) &&
                parent.type.allowsMarkType(markType)) {
                const oldMarks = node.marks.filter(mark => mark.type === markType);
                const prevAttrs = oldMarks.length ? oldMarks[0].attrs : undefined;
                const newAttrs = getAttrs(prevAttrs, node);
                if (newAttrs !== undefined) {
                    tr.setNodeMarkup(pos, node.type, node.attrs, node.marks
                        .filter(mark => !markType.excludes(mark.type))
                        .concat(newAttrs === false ? [] : markType.create(newAttrs)));
                    markApplied = true;
                }
            }
            return;
        });
    };
    const { from, to } = state.selection;
    toggleBlockMarkOnRange(from, to, tr);
    if (markApplied && tr.docChanged) {
        if (dispatch) {
            dispatch(tr.scrollIntoView());
        }
        return true;
    }
    return false;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vZ2xlLWJsb2NrLW1hcmsuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvaHRtbC1lZGl0b3IvcHJvc2VtaXJyb3IvY29tbWFuZHMvdG9vZ2xlLWJsb2NrLW1hcmsudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBSUE7Ozs7OztHQU1HO0FBQ0gsTUFBTSxDQUFDLE1BQU0sZUFBZSxHQUFHLENBQzNCLFFBQWtCLEVBQ2xCLFFBQW1FLEVBQ25FLGFBRWlFLEVBQzFELEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsRUFBRTtJQUM5QixJQUFJLFdBQVcsR0FBRyxLQUFLLENBQUM7SUFDeEIsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLEVBQUUsQ0FBQztJQUVwQixNQUFNLHNCQUFzQixHQUFHLENBQUMsSUFBWSxFQUFFLEVBQVUsRUFBRSxFQUFlLEVBQUUsRUFBRTtRQUV6RSxLQUFLLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFFLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsRUFBRTtZQUVuRCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUU7Z0JBQ3BCLE9BQU8sS0FBSyxDQUFDO2FBQ2hCO1lBRUQsSUFDSSxDQUFDLENBQUMsYUFBYSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO2dCQUN0SSxNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsRUFDdEM7Z0JBRUUsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxDQUFDO2dCQUVuRSxNQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBVyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7Z0JBQ3pFLE1BQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBRTNDLElBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtvQkFFeEIsRUFBRSxDQUFDLGFBQWEsQ0FDWixHQUFHLEVBQ0gsSUFBSSxDQUFDLElBQUksRUFDVCxJQUFJLENBQUMsS0FBSyxFQUNWLElBQUksQ0FBQyxLQUFLO3lCQUNMLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7eUJBQzdDLE1BQU0sQ0FBQyxRQUFRLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FDbkUsQ0FBQztvQkFFRixXQUFXLEdBQUcsSUFBSSxDQUFDO2lCQUN0QjthQUNKO1lBRUQsT0FBTztRQUVYLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQyxDQUFDO0lBRUYsTUFBTSxFQUFDLElBQUksRUFBRSxFQUFFLEVBQUMsR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDO0lBQ25DLHNCQUFzQixDQUFDLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFFckMsSUFBSSxXQUFXLElBQUksRUFBRSxDQUFDLFVBQVUsRUFBRTtRQUM5QixJQUFJLFFBQVEsRUFBRTtZQUNWLFFBQVEsQ0FBQyxFQUFFLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQztTQUNqQztRQUNELE9BQU8sSUFBSSxDQUFDO0tBQ2Y7SUFFRCxPQUFPLEtBQUssQ0FBQztBQUNqQixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge01hcmtUeXBlLCBOb2RlIGFzIFBNTm9kZSwgTm9kZVR5cGUsIFNjaGVtYX0gZnJvbSBcInByb3NlbWlycm9yLW1vZGVsXCI7XG5pbXBvcnQge1RyYW5zYWN0aW9ufSBmcm9tIFwicHJvc2VtaXJyb3Itc3RhdGVcIjtcbmltcG9ydCB7Q29tbWFuZH0gZnJvbSBcIi4uL2NvbW1hbmRcIjtcblxuLyoqXG4gKiBUb2dnbGVzIGJsb2NrIG1hcmsgYmFzZWQgb24gdGhlIHJldHVybiB0eXBlIG9mIGBnZXRBdHRyc2AuXG4gKiBUaGlzIGlzIHNpbWlsYXIgdG8gUHJvc2VNaXJyb3JcInMgYGdldEF0dHJzYCBmcm9tIGBBdHRyaWJ1dGVTcGVjYFxuICogcmV0dXJuIGBmYWxzZWAgdG8gcmVtb3ZlIHRoZSBtYXJrLlxuICogcmV0dXJuIGB1bmRlZmluZWQgZm9yIG5vLW9wLlxuICogcmV0dXJuIGFuIGBvYmplY3RgIHRvIHVwZGF0ZSB0aGUgbWFyay5cbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZUJsb2NrTWFyayA9IDxUID0gb2JqZWN0PihcbiAgICBtYXJrVHlwZTogTWFya1R5cGUsXG4gICAgZ2V0QXR0cnM6ICgocHJldkF0dHJzPzogVCwgbm9kZT86IFBNTm9kZSkgPT4gVCB8IHVuZGVmaW5lZCB8IGZhbHNlKSxcbiAgICBhbGxvd2VkQmxvY2tzPzpcbiAgICAgICAgfCBBcnJheTxOb2RlVHlwZT5cbiAgICAgICAgfCAoKHNjaGVtYTogU2NoZW1hLCBub2RlOiBQTU5vZGUsIHBhcmVudDogUE1Ob2RlKSA9PiBib29sZWFuKSxcbik6IENvbW1hbmQgPT4gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBtYXJrQXBwbGllZCA9IGZhbHNlO1xuICAgIGNvbnN0IHRyID0gc3RhdGUudHI7XG5cbiAgICBjb25zdCB0b2dnbGVCbG9ja01hcmtPblJhbmdlID0gKGZyb206IG51bWJlciwgdG86IG51bWJlciwgdHI6IFRyYW5zYWN0aW9uKSA9PiB7XG5cbiAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcywgcGFyZW50KSA9PiB7XG5cbiAgICAgICAgICAgIGlmICghbm9kZS50eXBlLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoIWFsbG93ZWRCbG9ja3MgfHwgKEFycmF5LmlzQXJyYXkoYWxsb3dlZEJsb2NrcykgPyBhbGxvd2VkQmxvY2tzLmluZGV4T2Yobm9kZS50eXBlKSA+IC0xIDogYWxsb3dlZEJsb2NrcyhzdGF0ZS5zY2hlbWEsIG5vZGUsIHBhcmVudCkpKSAmJlxuICAgICAgICAgICAgICAgIHBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG1hcmtUeXBlKVxuICAgICAgICAgICAgKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvbGRNYXJrcyA9IG5vZGUubWFya3MuZmlsdGVyKG1hcmsgPT4gbWFyay50eXBlID09PSBtYXJrVHlwZSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2QXR0cnMgPSBvbGRNYXJrcy5sZW5ndGggPyAob2xkTWFya3NbMF0uYXR0cnMgYXMgVCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3QXR0cnMgPSBnZXRBdHRycyhwcmV2QXR0cnMsIG5vZGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5ld0F0dHJzICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hdHRycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubWFya3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKG1hcmsgPT4gIW1hcmtUeXBlLmV4Y2x1ZGVzKG1hcmsudHlwZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChuZXdBdHRycyA9PT0gZmFsc2UgPyBbXSA6IG1hcmtUeXBlLmNyZWF0ZShuZXdBdHRycykpLFxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIG1hcmtBcHBsaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3Qge2Zyb20sIHRvfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICB0b2dnbGVCbG9ja01hcmtPblJhbmdlKGZyb20sIHRvLCB0cik7XG5cbiAgICBpZiAobWFya0FwcGxpZWQgJiYgdHIuZG9jQ2hhbmdlZCkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG4iXX0=